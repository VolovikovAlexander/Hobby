# Решение тестовой задачи.
### Редакция: 2023-01-15

## Постановка:
```
Пользователи участвуют в конкурсе и зарабатывают очки.
По окончанию конкурса показывается лидерборд с результатами. Чем больше очков набрал пользователь, тем выше его позиция.
Т.к. за первые 3 места предполагаются денежные выплаты, то есть минимальное количество очков, чтобы попасть на первые 3 места.

- Пользователь может занять первое место, только если набрал >= FirstPlaceMinScore очков
- Пользователь может занять второе место, только если набрал >= SecondPlaceMinScore очков
- Пользователь может занять третье место, только если набрал >= ThirdPlaceMinScore очков
  Если для какого-то места нет пользователя, набравшего достаточно очков, то это место остаётся пустым.

Необходимо реализовать функцию CalculatePlaces в классе LeaderboardCalculator. 
Результат прислать в виде архива проекта или одного файла LeaderboardCalculator.cs.
- Файл LeaderboardCalculator.cs содержит требования к функции и ограничения на неё
- Файл LeaderboardCalculatorTests.cs содержит базовые тесты (написаны только самые простейшие тесты, что бы была понятна логика работы функции)
```

Исходный текст переданной задачи расположен в каталоге **Legacy**

Для решения данной задачи я решил немного исправить модели и ввести интерфейсы для всех данных.
Пример:
```csharp

/// <summary>
/// Интерфейс - описание пользователя
/// </summary>
public interface IUser
{
    /// <summary>
    /// Уникальный код пользователя
    /// </summary>
    public long UserId { get;  set; }
}

```

Далее, структуры, связанные с пользователем унаследовать от IUser
```csharp
/// <summary>
/// Интерфейс - описание связки пользователя с его местом (рейтингом)
/// </summary>
public interface IUserWithPlace: IUser
{
    /// <summary>
    /// Место в рейтинги по баллам
    /// </summary>
    public LeaderboardPlace Place { get;  set; }
}
```

Для разработки основного алгоритма, я исключил сервис (зачем один сервис с одним методом?). Сделал все с использованием паттерна проектирование /Построитель/ - Flient Builder. 
Так же, заменил все автотесты. В тестах я формирую разное количество записей для проверки.

Все проверки на корректность данных, включены в классы Builder для реализации указанных условий. Пример:

```csharp
    /// <summary>
    /// Сформировать необходимое количество пользователей с произвольными баллами
    /// </summary>
    /// <param name="size"> Количество пользователей </param>
    /// <returns></returns>
    /// <exception cref="ArgumentException"></exception>
    public static IEnumerable<IUserWithScore> Create(int size)
    {
        if (size < 4)
            throw new ArgumentException("Некорректно указано колличество пользователей! Должно быть больше 3-ех");

        return Enumerable.Range(0, size)
            .Select(x => new UserWithScore()
            {
                UserId = _rnd.NextInt64(9999), Score = _rnd.Next(9999)
            }).ToList();
    }
```

Основной код для создания рейтинга включен в расширение  **BuildRank** в виде LINQ запросов. Для построение матрицы рейтингов, используется Reflection выполка аттрибутов по классу настроек 
(см атрибут LeaderboardAttribute).

```csharp
    public static IEnumerable<IUserWithPlace> BuildRank(this IEnumerable<IUserWithScore> source,
        ILeaderboardMinScores settings)
```

```csharp
    /// <summary>
    /// Количество баллов для первого места
    /// </summary>
    [Leaderboard(LeaderboardPlace.First)]
    public int FirstPlaceMinScore { get; set; }
```

## Недостатки:
1. Для построения рейтинга, используется Reflection каждый раз. Полагаю, при большой нагрузке, данный подход может "тормозить" код. Тут строит провести кеширование. 
2. Недостаточно оптимальный вариант ранжирование. Сейчас для каждой записи идет перебор (сопоставление со словарем IDictionary<,>) тогда как можно два списка одним LINQ
запросов сразу же объединить.
```csharp

        // Получаем список с рейтингом для всех записей
        var items
            = source.Select(x => new UserWithPlace()
            {
                UserId = x.UserId,
                Place = BuildRank(ranks, x.Score)
            }).Where(x => x.Place != LeaderboardPlace.None)
                .ToList();
```